import os
import logging
import json
import traceback
from typing import Dict, Any, List, Optional
from openai import OpenAI
from config import get_openai_api_key

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('ai_insights_gpt')

# Configuration imported from config module - uses environment variables only

def generate_insights_with_gpt(comparison_results: Dict[str, Any], property_name: str = "") -> Dict[str, Any]:
    """
    Generate professional real estate accounting insights from DETAILED NOI comparison results using GPT.

    Args:
        comparison_results: Results from calculate_noi_comparisons() using detailed data.
        property_name: Name of the property for the analysis.

    Returns:
        Dictionary with professional insights generated by GPT.
    """
    logger.info(f"Generating detailed insights with GPT for property: {property_name}")
    logger.info(f"Comparison results received: {json.dumps(comparison_results, indent=2)}")

    # Get API key from config, which checks environment variables and session state
    api_key = get_openai_api_key()
    
    # Log API key status (masked)
    if api_key and len(api_key) > 10:
        logger.info(f"Using OpenAI API key: {'*' * (len(api_key) - 5)}{api_key[-5:]}")
    else:
        logger.error("Invalid or missing OpenAI API key. Cannot generate insights.")
        return {
            "summary": "Error: OpenAI API key is not configured correctly.",
            "performance": [],
            "recommendations": []
        }

    # Check if comparison_results is empty or invalid
    if not comparison_results or not isinstance(comparison_results, dict):
        logger.error(f"Invalid comparison results: {comparison_results}")
        return {
            "summary": "Error: Invalid comparison data received. Unable to generate insights.",
            "performance": ["No valid financial data was provided for analysis."],
            "recommendations": ["Please ensure financial data is properly uploaded and processed."]
        }

    # Initialize OpenAI client with API key
    client = OpenAI(api_key=api_key)

    # Format DETAILED comparison results for the prompt
    formatted_results = format_detailed_comparison_results_for_prompt(comparison_results)

    # Create the DETAILED prompt for GPT
    prompt = f"""
You are a senior real estate financial analyst providing insights on property performance based on detailed Net Operating Income (NOI) variance analysis. Your analysis must be data-driven, concise, and actionable.

Property Name: {property_name or "This Property"}

Analyze the following financial comparison data:
---
{formatted_results}
---

Based *only* on the data provided, please provide:
1.  **Executive Summary:** A concise overview of the property's financial performance, highlighting the main drivers of NOI changes compared to budget and prior periods. Mention key metrics like EGI, Vacancy, and OpEx trends. Limit to 2-3 sentences.
2.  **Key Performance Insights (3-5 bullet points):** Specific, data-driven observations about significant variances or trends in revenue components (GPR, Vacancy, Other Income), operating expenses (major categories), and overall NOI. Quantify insights where possible (e.g., "Vacancy loss decreased by X%, contributing Y to NOI improvement"). Focus on the most impactful changes.
3.  **Actionable Recommendations (3-5 bullet points):** Concrete suggestions based *directly* on the observed variances to improve NOI. Focus on areas like reducing specific expenses, improving rent collection/reducing vacancy, increasing other income, or investigating budget variances. Prioritize recommendations with the highest potential impact.

Your reply **must** follow this exact Markdown template (replace bracketed text with your content):

### Executive Summary
[Concise narrative paragraph(s)]

### Key Performance Insights
- [Insight 1]
- [Insight 2]
- [Insight 3]

### Actionable Recommendations
- [Recommendation 1]
- [Recommendation 2]
- [Recommendation 3]

Only include the sections shown above â€“ no additional commentary, headers or footnotes. Be professional, objective and data-driven. Focus on the most significant findings and avoid minor fluctuations.
"""

    logger.info(f"Sending detailed prompt to GPT API (length: {len(prompt)} chars)...")
    logger.debug(f"GPT Prompt:\n{prompt}")

    try:
        # Call OpenAI API with optimized settings for better performance
        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": "You are a senior real estate financial analyst specializing in detailed NOI variance analysis and reporting. You provide concise, actionable insights based on financial data with a focus on accuracy and relevance."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.3,  # Optimized: Lower temperature for faster, more consistent responses
            max_tokens=800    # Optimized: Reduced tokens for better performance and cost
        )

        # Log the response
        response_content = response.choices[0].message.content if response.choices[0].message.content else ""
        logger.info(f"Received response from GPT API (length: {len(response_content)} chars).")
        logger.debug(f"GPT Raw Response:\n{response_content}")

        # Parse the content into our expected format (using existing parser, should handle sections)
        insights = parse_gpt_response(response_content) # Reuse existing parser

        return insights
    except Exception as e:
        logger.error(f"Error generating insights with GPT: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        return {
            "summary": f"Error generating insights: {str(e)}. Please check logs.",
            "performance": ["Unable to generate performance insights due to an error."],
            "recommendations": ["Please try again or contact support."]
        }

def format_detailed_comparison_results_for_prompt(comparison_results: Dict[str, Any]) -> str:
    """
    Formats the DETAILED comparison results into a string for the GPT prompt.

    Args:
        comparison_results: Results from calculate_noi_comparisons() using detailed data.

    Returns:
        Formatted string with detailed comparison results.
    """
    formatted_text = ""
    
    # Log the structure of comparison_results for debugging
    logger.info(f"Formatting comparison results with keys: {list(comparison_results.keys())}")
    
    # Handle case where comparison_results might be empty or missing expected keys
    if not comparison_results:
        return "No comparison data available."
    
    current = comparison_results.get("current", {})
    if not current:
        logger.warning("No current period data found in comparison results")
        current = {}

    def format_value(value):
        """Formats numbers, handling None."""
        if value is None:
            return "N/A"
        try:
            return f"${float(value):,.2f}"
        except (ValueError, TypeError):
            return "N/A"

    def format_change(change, percentage):
        """Formats change and percentage."""
        try:
            change_str = format_value(change)
            percent_str = f"{float(percentage):.1f}%" if percentage is not None else "N/A"
            indicator = "+" if change and change > 0 else "" if change == 0 else ""
            return f"{indicator}{change_str} ({percent_str})"
        except (ValueError, TypeError):
            return "N/A"

    # --- Current Period ---
    if current:
        formatted_text += "CURRENT PERIOD DATA:\n"
        formatted_text += f"- Gross Potential Rent (GPR): {format_value(current.get('gpr'))}\n"
        formatted_text += f"- Vacancy & Credit Loss: {format_value(current.get('vacancy_loss'))}\n"
        formatted_text += f"- Other Income: {format_value(current.get('other_income'))}\n"
        formatted_text += f"- Effective Gross Income (EGI): {format_value(current.get('egi'))}\n"
        formatted_text += f"- Total Operating Expenses (OpEx): {format_value(current.get('opex'))}\n"
        formatted_text += f"- Net Operating Income (NOI): {format_value(current.get('noi'))}\n\n"

    # --- Actual vs. Budget ---
    avb = comparison_results.get("actual_vs_budget", {})
    if avb and current:
        formatted_text += "ACTUAL VS BUDGET COMPARISON:\n"
        formatted_text += f"Metric          | Actual         | Budget         | Variance ($)   | Variance (%)\n"
        formatted_text += f"----------------|----------------|----------------|----------------|--------------\n"
        for key, name in [("gpr", "GPR"), ("vacancy_loss", "Vacancy Loss"), ("other_income", "Other Income"),
                          ("egi", "EGI"), ("opex", "Total OpEx"), ("noi", "NOI")]:
            actual = current.get(key, 0.0)
            budget = avb.get(f"{key}_budget", 0.0)
            variance = avb.get(f"{key}_variance", 0.0)
            percent_var = avb.get(f"{key}_percent_variance", 0.0)
            
            # Handle potential None values
            actual = 0.0 if actual is None else actual
            budget = 0.0 if budget is None else budget
            variance = 0.0 if variance is None else variance
            percent_var = 0.0 if percent_var is None else percent_var
            
            formatted_text += f"{name:<15} | {format_value(actual):<14} | {format_value(budget):<14} | {format_value(variance):<14} | {percent_var:>10.1f}%\n"
        formatted_text += "\n"

    # --- Year-over-Year ---
    yoy = comparison_results.get("year_vs_year", {})
    if yoy and current:
        formatted_text += "YEAR-OVER-YEAR COMPARISON:\n"
        formatted_text += f"Metric          | Current Year   | Prior Year     | Change ($)     | Change (%)\n"
        formatted_text += f"----------------|----------------|----------------|----------------|--------------\n"
        for key, name in [("gpr", "GPR"), ("vacancy_loss", "Vacancy Loss"), ("other_income", "Other Income"),
                          ("egi", "EGI"), ("opex", "Total OpEx"), ("noi", "NOI")]:
            actual = current.get(key, 0.0)
            prior = yoy.get(f"{key}_prior_year", 0.0)
            change = yoy.get(f"{key}_change", 0.0)
            percent_change = yoy.get(f"{key}_percent_change", 0.0)
            
            # Handle potential None values
            actual = 0.0 if actual is None else actual
            prior = 0.0 if prior is None else prior
            change = 0.0 if change is None else change
            percent_change = 0.0 if percent_change is None else percent_change
            
            formatted_text += f"{name:<15} | {format_value(actual):<14} | {format_value(prior):<14} | {format_value(change):<14} | {percent_change:>10.1f}%\n"
        formatted_text += "\n"

    # --- Month-over-Month ---
    mom = comparison_results.get("month_vs_prior", {})
    if mom and current:
        formatted_text += "MONTH-OVER-MONTH COMPARISON:\n"
        formatted_text += f"Metric          | Current Month  | Prior Month    | Change ($)     | Change (%)\n"
        formatted_text += f"----------------|----------------|----------------|----------------|--------------\n"
        for key, name in [("gpr", "GPR"), ("vacancy_loss", "Vacancy Loss"), ("other_income", "Other Income"),
                          ("egi", "EGI"), ("opex", "Total OpEx"), ("noi", "NOI")]:
            actual = current.get(key, 0.0)
            prior = mom.get(f"{key}_prior", 0.0)
            change = mom.get(f"{key}_change", 0.0)
            percent_change = mom.get(f"{key}_percent_change", 0.0)
            
            # Handle potential None values
            actual = 0.0 if actual is None else actual
            prior = 0.0 if prior is None else prior
            change = 0.0 if change is None else change
            percent_change = 0.0 if percent_change is None else percent_change
            
            formatted_text += f"{name:<15} | {format_value(actual):<14} | {format_value(prior):<14} | {format_value(change):<14} | {percent_change:>10.1f}%\n"
        formatted_text += "\n"

    # If no comparison data was available, provide a fallback
    if not (avb or yoy or mom):
        formatted_text += "\nNo comparison data available. Only current period data is shown.\n"

    return formatted_text.strip()

def parse_gpt_response(response_text: str) -> Dict[str, Any]:
    """
    Parse the GPT response into a structured format.

    Args:
        response_text: Raw text response from GPT.

    Returns:
        Dictionary with parsed insights.
    """
    insights = {
        "summary": "",
        "performance": [],
        "recommendations": []
    }

    # Simple but effective parsing approach
    sections: Dict[str, Optional[int]] = {
        "summary": None,
        "performance": None,
        "recommendations": None
    }
    
    # First pass: identify section boundaries
    lines = response_text.split('\n')
    for i, line in enumerate(lines):
        line = line.strip()
        if not line:
            continue
        
        # Look for executive summary section
        if line and (
            "executive summary" in line.lower() or 
            "summary:" in line.lower() or 
            line.lower().startswith("1.") and "summary" in line.lower()
        ):
            sections["summary"] = i
        # Look for performance insights section
        elif line and (
            "key performance" in line.lower() or 
            "performance insights" in line.lower() or
            line.lower().startswith("2.") and "performance" in line.lower()
        ):
            sections["performance"] = i
        # Look for recommendations section
        elif line and (
            "recommendations" in line.lower() or 
            "actionable recommendations" in line.lower() or
            line.lower().startswith("3.") and "recommend" in line.lower()
        ):
            sections["recommendations"] = i
    
    # If we couldn't find any sections, try to infer them
    if sections["summary"] is None and sections["performance"] is None and sections["recommendations"] is None:
        # Assume first paragraph is summary
        sections["summary"] = 0
        
        # Look for bullet points to identify other sections
        for i, line in enumerate(lines):
            if i > 0 and (line.strip().startswith('-') or line.strip().startswith('â€¢')):
                if sections["performance"] is None:
                    sections["performance"] = i
                elif sections["recommendations"] is None:
                    sections["recommendations"] = i
                    break
    
    # Second pass: extract content from each section
    section_ranges = []
    section_keys = ["summary", "performance", "recommendations"]
    
    # Create section ranges
    for i, key in enumerate(section_keys):
        if sections[key] is not None:
            start = sections[key]
            end = None
            
            # Find the end of this section (start of next section or end of text)
            for next_key in section_keys[i+1:]:
                if sections[next_key] is not None:
                    end = sections[next_key]
                    break
            
            section_ranges.append((key, start, end))
    
    # Process each section
    for section, start, end in section_ranges:
        section_lines = lines[start:end] if end else lines[start:]
        
        # Skip the header line for each section
        if section_lines and any(marker in section_lines[0].lower() for marker in ["summary", "performance", "recommendations", "action"]):
            section_lines = section_lines[1:]
        
        # Process based on section type
        if section == "summary":
            # Join all lines for summary
            insights["summary"] = " ".join([line.strip() for line in section_lines if line.strip()])
        else:
            # Process bullet points for performance and recommendations
            current_point = ""
            for line in section_lines:
                line = line.strip()
                if not line:
                    continue
                
                # Check if this is a new bullet point
                if line.startswith('-') or line.startswith('â€¢') or (line[0].isdigit() and len(line) > 1 and line[1] in ['.', ')']):
                    # Save previous point if exists
                    if current_point:
                        insights[section].append(current_point)
                    
                    # Start new point (remove bullet)
                    current_point = line.lstrip('-â€¢0123456789.) ')
                else:
                    # Continue previous point
                    if current_point:
                        current_point += " " + line
            
            # Add the last point if exists
            if current_point:
                insights[section].append(current_point)
    
    # If we still don't have a summary, use the first paragraph
    if not insights["summary"]:
        paragraphs = [p for p in response_text.split('\n\n') if p.strip()]
        if paragraphs:
            insights["summary"] = paragraphs[0].strip()
    
    # Provide fallback content if sections are empty
    if not insights["summary"]:
        insights["summary"] = "Unable to generate a summary from the financial data."
    
    if not insights["performance"]:
        insights["performance"] = ["No performance insights could be extracted from the available data."]
    
    if not insights["recommendations"]:
        insights["recommendations"] = ["No recommendations could be generated based on the available data."]
    
    # Log the parsed insights for debugging
    logger.info(f"Parsed insights: summary={bool(insights['summary'])}, performance={len(insights['performance'])}, recommendations={len(insights['recommendations'])}")
    
    return insights

def ask_noi_coach(question: str, comparison_results: Dict[str, Any], current_view: Optional[str] = None) -> str:
    """
    Ask the NOI Coach to answer a free-form question
    based on the current comparison_results, with awareness of which comparison tab is active.
    
    Args:
        question: The user's question about NOI data
        comparison_results: The complete NOI comparison results dictionary
        current_view: The currently selected comparison view (budget, prior_year, prior_month)
        
    Returns:
        String response from the AI coach
    """
    api_key = get_openai_api_key()
    client = OpenAI(api_key=api_key)

    # Format the metrics for the prompt
    formatted = format_detailed_comparison_results_for_prompt(comparison_results)
    
    # Determine which comparison data to focus on based on current view
    focus_section = ""
    if current_view:
        if current_view == "budget":
            focus_section = "You should focus primarily on the ACTUAL VS BUDGET COMPARISON in your analysis, as the user is currently viewing budget comparison data."
        elif current_view == "prior_year":
            focus_section = "You should focus primarily on the YEAR-OVER-YEAR COMPARISON in your analysis, as the user is currently viewing year-over-year comparison data."
        elif current_view == "prior_month":
            focus_section = "You should focus primarily on the MONTH-OVER-MONTH COMPARISON in your analysis, as the user is currently viewing month-over-month comparison data."
    
    system = (
      "You are a specialized NOI (Net Operating Income) coach for real estate professionals analyzing property financial performance. "
      "Your role is to provide clear, concise, and actionable answers to specific questions about the financial data. "
      f"Use ONLY the data provided in the detailed comparison results. {focus_section} "
      "Be precise with numbers and percentages. "
      "For metrics like vacancy and expenses, note that negative variances (decreases) are generally positive outcomes. "
      "Provide practical insights that help property managers make informed decisions. "
      "Keep responses focused and avoid generic statements."
    )
    
    user = (
      f"Here are the detailed NOI comparison results:\n\n{formatted}\n\n"
      f"User question: {question}\n\n"
      "Please provide a focused, data-driven answer to the user's question using only the provided financial data. "
      "Include specific dollar amounts and percentages where relevant. "
      "Limit your response to 3-4 concise sentences."
    )

    logger.info(f"Sending NOI coach request with current_view: {current_view}")
    
    resp = client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[
          {"role": "system", "content": system},
          {"role": "user",   "content": user}
        ],
        temperature=0.3,
        max_tokens=500
    )
    return resp.choices[0].message.content.strip() if resp.choices[0].message.content else ""
