import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import logging
import os
import json
import copy
import time
from typing import Dict, Any, List, Optional, Tuple
import base64
from datetime import datetime
import io
from jinja2 import Environment, FileSystemLoader

# Try to import weasyprint for PDF generation
try:
    from weasyprint import HTML
    WEASYPRINT_AVAILABLE = True
except ImportError:
    WEASYPRINT_AVAILABLE = False
    # Create dummy HTML class for fallback
    class HTMLFallback:
        def __init__(self, *args, **kwargs):
            pass
        def write_pdf(self, *args, **kwargs):
            raise ImportError("WeasyPrint not available - PDF generation disabled")

    # Assign the fallback class to HTML only when weasyprint is not available
    HTML = HTMLFallback

import tempfile
import jinja2
import streamlit.components.v1 as components
import math
import html
from constants import OPEX_COMPONENTS, INCOME_COMPONENTS

# Import and initialize Sentry for error tracking
from sentry_config import (
    init_sentry, set_user_context, add_breadcrumb, 
    capture_exception_with_context, capture_message_with_context, 
    monitor_performance
)

# Import centralized logging configuration
from logging_config import setup_logging, get_logger

# Initialize logging first
setup_logging()
logger = get_logger(__name__)

# Initialize Sentry as early as possible
sentry_initialized = init_sentry()

from utils.helpers import format_for_noi_comparison
from noi_calculations import calculate_noi_comparisons
from noi_tool_batch_integration import process_all_documents
from ai_extraction import extract_noi_data
from ai_insights_gpt import generate_insights_with_gpt

# Try to import specific functions that might be missing in minimal setups
try:
    from financial_storyteller import create_narrative
    from storyteller_display import display_financial_narrative, display_narrative_in_tabs
except ImportError:
    # Create dummy functions if not available
    def create_narrative(comparison_results: Dict[str, Any], property_name: str = "") -> str:
        return "Narrative generation not available - module not found."
    def display_financial_narrative(*args, **kwargs):
        pass
    def display_narrative_in_tabs(*args, **kwargs):
        pass

# Try to import the NOI Coach module
try:
    from noi_coach import display_noi_coach as display_noi_coach_enhanced
    NOI_COACH_AVAILABLE = True
except ImportError:
    NOI_COACH_AVAILABLE = False
    def display_noi_coach_enhanced():
        st.error("NOI Coach module not available. Please ensure noi_coach.py is in the project directory.")

# Try to import credit system modules
try:
    from utils.credit_ui_minimal import display_credit_store
    # Import other functions from original credit_ui as fallback for other functions
    from utils.credit_ui import display_credit_balance, display_credit_balance_header, check_credits_for_analysis
    # Try to import optional functions, provide fallbacks if not available
    try:
        from utils.credit_ui import display_insufficient_credits
    except ImportError:
        def display_insufficient_credits(): pass
    try:
        from utils.credit_ui import display_free_trial_welcome
    except ImportError:
        def display_free_trial_welcome(email: str): pass
    try:
        from utils.credit_ui import init_credit_system
    except ImportError:
        def init_credit_system(): pass
    CREDIT_SYSTEM_AVAILABLE = True
except ImportError:
    # Fallback to robust implementation if minimal is not available
    try:
        from utils.credit_ui_robust import display_credit_store
        # Import other functions from original credit_ui as fallback
        from utils.credit_ui import display_credit_balance, display_credit_balance_header, check_credits_for_analysis
        # Try to import optional functions, provide fallbacks if not available
        try:
            from utils.credit_ui import display_insufficient_credits
        except ImportError:
            def display_insufficient_credits(): pass
        try:
            from utils.credit_ui import display_free_trial_welcome
        except ImportError:
            def display_free_trial_welcome(email: str): pass
        try:
            from utils.credit_ui import init_credit_system
        except ImportError:
            def init_credit_system(): pass
        CREDIT_SYSTEM_AVAILABLE = True
    except ImportError:
        # Fallback to fresh implementation if robust is not available
        try:
            from utils.credit_ui_fresh import display_credit_store
            # Import other functions from original credit_ui as fallback
            from utils.credit_ui import display_credit_balance, display_credit_balance_header, check_credits_for_analysis
            # Try to import optional functions, provide fallbacks if not available
            try:
                from utils.credit_ui import display_insufficient_credits
            except ImportError:
                def display_insufficient_credits(): pass
            try:
                from utils.credit_ui import display_free_trial_welcome
            except ImportError:
                def display_free_trial_welcome(email: str): pass
            try:
                from utils.credit_ui import init_credit_system
            except ImportError:
                def init_credit_system(): pass
            CREDIT_SYSTEM_AVAILABLE = True
        except ImportError:
            # Fallback to original credit_ui if fresh implementation is not available
            try:
                from utils.credit_ui import display_credit_balance, display_credit_balance_header, display_credit_store, check_credits_for_analysis
                # Try to import optional functions, provide fallbacks if not available
                try:
                    from utils.credit_ui import display_insufficient_credits
                except ImportError:
                    def display_insufficient_credits(): pass
                try:
                    from utils.credit_ui import display_free_trial_welcome
                except ImportError:
                    def display_free_trial_welcome(email: str): pass
                try:
                    from utils.credit_ui import init_credit_system
                except ImportError:
                    def init_credit_system(): pass
                CREDIT_SYSTEM_AVAILABLE = True
            except ImportError:
                CREDIT_SYSTEM_AVAILABLE = False
                def display_credit_balance(email: str): pass
                def display_credit_balance_header(email: str): pass
                def display_credit_store(): st.error("Credit system not available")
                def check_credits_for_analysis(email: str) -> tuple[bool, str]: return True, "Credit check unavailable"
                def display_insufficient_credits(): pass
                def display_free_trial_welcome(email: str): pass
                def init_credit_system(): pass

# Import mock data generators for testing mode
try:
    from mock_data import (
        generate_mock_consolidated_data,
        generate_mock_insights,
        generate_mock_narrative
    )
    MOCK_DATA_AVAILABLE = True
except ImportError:
    MOCK_DATA_AVAILABLE = False
    def generate_mock_consolidated_data(property_name: str = "Test Property", scenario: str = "Standard Performance") -> Dict[str, Any]:
        return {"error": "Mock data module not available"}
    def generate_mock_insights(scenario: str = "Standard Performance") -> Dict[str, Any]:
        return {"summary": "Mock insights not available", "performance": [], "recommendations": []}
    def generate_mock_narrative(scenario: str = "Standard Performance") -> str:
        return "Mock narrative not available"

from config import get_openai_api_key, get_extraction_api_url, get_api_key, save_api_settings
from insights_display import display_insights
from reborn_logo import get_reborn_logo_base64
from utils.ui_helpers import (
    show_processing_status, display_loading_spinner, display_progress_bar,
    display_inline_loading, LoadingContext, get_loading_message_for_action,
    create_loading_button, show_button_loading, restore_button
)

# Constants for testing mode
TESTING_MODE_ENV_VAR = "NOI_ANALYZER_TESTING_MODE"
DEFAULT_TESTING_MODE = os.getenv(TESTING_MODE_ENV_VAR, "false").lower() == "true"

# Helper function to check if testing mode is active
def is_testing_mode_active() -> bool:
    """
    Determine if testing mode is currently active.
    
    Returns:
        bool: True if testing mode is active, False otherwise
    """
    return st.session_state.get("testing_mode", DEFAULT_TESTING_MODE)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("noi_analyzer_enhanced.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger('noi_analyzer')

# Log Sentry initialization status
if sentry_initialized:
    logger.info("Sentry error tracking initialized successfully")
    add_breadcrumb("Application started", "app", "info")
else:
    logger.warning("Sentry error tracking not initialized - check SENTRY_DSN environment variable")

def safe_text(value):
    """Convert any value to a safe string, avoiding 'undefined' text."""
    if value is None or value == "undefined" or value == "null" or str(value).lower() == "nan" or (isinstance(value, float) and math.isnan(value)):
        return ""
    return str(value)

def save_testing_config():
    """Save testing mode configuration to a file"""
    if not is_testing_mode_active():
        return
    
    config = {
        "testing_mode": st.session_state.get("testing_mode", False),
        "mock_property_name": st.session_state.get("mock_property_name", "Test Property"),
        "mock_scenario": st.session_state.get("mock_scenario", "Standard Performance")
    }
    
    try:
        from pathlib import Path
        config_dir = Path("./config")
        
        # Try to create directory, but handle permission errors gracefully
        try:
            config_dir.mkdir(exist_ok=True)
        except (PermissionError, OSError) as e:
            logger.warning(f"Cannot create config directory (insufficient permissions): {str(e)}")
            # Try using session state as fallback instead of file persistence
            st.session_state._testing_config_cache = config
            logger.info("Testing configuration cached in session state as fallback")
            return
        
        # Try to save to file
        config_file = config_dir / "testing_config.json"
        with open(config_file, "w") as f:
            json.dump(config, f)
        logger.info("Testing configuration saved to file")
        
    except Exception as e:
        logger.warning(f"Error saving testing configuration to file: {str(e)}")
        # Use session state as fallback
        try:
            st.session_state._testing_config_cache = config
            logger.info("Testing configuration cached in session state as fallback")
        except Exception as fallback_error:
            logger.error(f"Failed to save testing configuration even to session state: {str(fallback_error)}")

def load_testing_config():
    """Load testing mode configuration from file or session state fallback"""
    try:
        from pathlib import Path
        config_file = Path("./config/testing_config.json")
        
        # Try to load from file first
        if config_file.exists():
            try:
                with open(config_file, "r") as f:
                    config = json.load(f)
                logger.info("Testing configuration loaded from file")
            except Exception as e:
                logger.warning(f"Error reading testing configuration file: {str(e)}")
                config = None
        else:
            config = None
        
        # If file loading failed, try session state fallback
        if config is None and hasattr(st.session_state, '_testing_config_cache'):
            config = st.session_state._testing_config_cache
            logger.info("Testing configuration loaded from session state fallback")
        
        # Apply configuration if available
        if config:
            st.session_state.testing_mode = config.get("testing_mode", DEFAULT_TESTING_MODE)
            st.session_state.mock_property_name = config.get("mock_property_name", "Test Property")
            st.session_state.mock_scenario = config.get("mock_scenario", "Standard Performance")
            logger.info("Testing configuration applied successfully")
        
    except Exception as e:
        logger.warning(f"Error loading testing configuration: {str(e)}")
        # Continue with default values - not a critical error

def display_testing_mode_indicator():
    """Display a visual indicator when testing mode is enabled"""
    if is_testing_mode_active():
        scenario = st.session_state.get("mock_scenario", "Standard Performance")
        
        # Color coding based on scenario
        if scenario == "High Growth":
            color = "#22C55E"  # Green
            emoji = "üìà"
        elif scenario == "Declining Performance":
            color = "#EF4444"  # Red
            emoji = "üìâ"
        elif scenario == "Budget Variance":
            color = "#F59E0B"  # Amber
            emoji = "‚öñÔ∏è"
        else:  # Standard Performance
            color = "#3B82F6"  # Blue
            emoji = "üìä"
        
        # Convert hex to RGB for alpha transparency
        hex_color = color.lstrip('#')
        rgb = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
        
        st.markdown(
            f"""
            <div style="
                background-color: rgba({rgb[0]}, {rgb[1]}, {rgb[2]}, 0.1);
                border-left: 4px solid {color};
                padding: 0.75rem 1rem;
                margin-bottom: 1rem;
                border-radius: 4px;
                display: flex;
                align-items: center;
            ">
                <span style="
                    font-size: 1.2rem;
                    margin-right: 0.75rem;
                ">{emoji}</span>
                <div>
                    <span style="
                        color: {color};
                        font-weight: 600;
                        display: block;
                        margin-bottom: 0.25rem;
                    ">Testing Mode Active</span>
                    <span style="
                        color: #E0E0E0;
                        font-size: 0.9rem;
                    ">Scenario: {scenario}</span>
                </div>
            </div>
            """,
            unsafe_allow_html=True
        )

def process_documents_testing_mode():
    """Process documents in testing mode using mock data"""
    logger.info("Testing mode enabled, using mock data")
    
    # Get property name and scenario from session state
    property_name = st.session_state.get("mock_property_name", "Test Property")
    scenario = st.session_state.get("mock_scenario", "Standard Performance")
    
    # Log the testing configuration
    logger.info(f"Generating mock data for property: {property_name}, scenario: {scenario}")
    
    try:
        # Generate mock consolidated data with the selected scenario
        mock_data = generate_mock_consolidated_data(property_name, scenario)
        
        # Store in session state - this mimics what happens after real document processing
        st.session_state.consolidated_data = mock_data
        st.session_state.template_viewed = True  # Skip template verification step
        st.session_state.processing_completed = True
        
        # Calculate comparisons using the mock data - this uses the real calculation logic
        st.session_state.comparison_results = calculate_noi_comparisons(mock_data)
        
        # Debug the generated data
        debug_testing_mode_data()
        
        # Generate mock insights - this replaces the API call to OpenAI
        st.session_state.insights = generate_mock_insights(scenario)
        
        # Generate mock narrative - this replaces the API call for narrative generation
        mock_narrative = generate_mock_narrative(scenario)
        st.session_state.generated_narrative = mock_narrative
        st.session_state.edited_narrative = mock_narrative  # Initialize edited to same as generated
        
        logger.info(f"Mock data processing completed for scenario: {scenario}")
        return True
    except Exception as e:
        logger.error(f"Error generating mock data: {str(e)}", exc_info=True)
        st.error("An error occurred while generating mock data. Please check the logs.")
        return False


def run_testing_mode_diagnostics():
    """Run diagnostics on testing mode functionality"""
    if not is_testing_mode_active():
        return
    
    # Only run diagnostics when explicitly triggered
    if not st.session_state.get("run_diagnostics", False):
        return
    
    logger.info("Running testing mode diagnostics")
    
    # Check if mock data was generated correctly
    if "consolidated_data" not in st.session_state:
        logger.error("Diagnostics: consolidated_data not found in session state")
        st.sidebar.error("Diagnostics: Mock data generation failed")
    else:
        logger.info("Diagnostics: consolidated_data present in session state")
        st.sidebar.success("Diagnostics: Mock data generated successfully")
    
    # Check if comparisons were calculated
    if "comparison_results" not in st.session_state:
        logger.error("Diagnostics: comparison_results not found in session state")
        st.sidebar.error("Diagnostics: Comparison calculation failed")
    else:
        logger.info("Diagnostics: comparison_results present in session state")
        st.sidebar.success("Diagnostics: Comparisons calculated successfully")
    
    # Check if insights were generated
    if "insights" not in st.session_state:
        logger.error("Diagnostics: insights not found in session state")
        st.sidebar.error("Diagnostics: Mock insights generation failed")
    else:
        logger.info("Diagnostics: insights present in session state")
        st.sidebar.success("Diagnostics: Mock insights generated successfully")
    
    # Check if narrative was generated
    if "generated_narrative" not in st.session_state:
        logger.error("Diagnostics: generated_narrative not found in session state")
        st.sidebar.error("Diagnostics: Mock narrative generation failed")
    else:
        logger.info("Diagnostics: generated_narrative present in session state")
        st.sidebar.success("Diagnostics: Mock narrative generated successfully")
    
    # Reset diagnostic flag
    st.session_state.run_diagnostics = False

def debug_testing_mode_data():
    """Debug function to inspect testing mode data structure"""
    if not is_testing_mode_active():
        return
    
    logger.info("=== TESTING MODE DATA DEBUG ===")
    
    # Debug consolidated_data
    if "consolidated_data" in st.session_state:
        consolidated_data = st.session_state.consolidated_data
        logger.info(f"Consolidated data keys: {list(consolidated_data.keys())}")
        
        for key, data in consolidated_data.items():
            if isinstance(data, dict) and key in ["current_month", "prior_month", "budget", "prior_year"]:
                logger.info(f"{key} data sample: gpr={data.get('gpr')}, noi={data.get('noi')}, egi={data.get('egi')}")
            elif key == "property_name":
                logger.info(f"Property name: {data}")
    else:
        logger.error("No consolidated_data found in session state")
    
    # Debug comparison_results
    if "comparison_results" in st.session_state:
        comparison_results = st.session_state.comparison_results
        logger.info(f"Comparison results keys: {list(comparison_results.keys())}")
        
        # Check each comparison section
        for section in ["month_vs_prior", "actual_vs_budget", "year_vs_year"]:
            if section in comparison_results:
                section_data = comparison_results[section]
                logger.info(f"{section} has {len(section_data)} fields")
                # Log a few sample fields
                sample_keys = [k for k in section_data.keys() if 'gpr' in k or 'noi' in k][:5]
                for key in sample_keys:
                    logger.info(f"  {key}: {section_data.get(key)}")
            else:
                logger.error(f"Missing {section} in comparison_results")
        
        # Check raw data sections
        for section in ["current", "prior", "budget", "prior_year"]:
            if section in comparison_results:
                section_data = comparison_results[section]
                if isinstance(section_data, dict):
                    logger.info(f"{section} raw data: gpr={section_data.get('gpr')}, noi={section_data.get('noi')}")
                else:
                    logger.error(f"{section} is not a dict: {type(section_data)}")
            else:
                logger.warning(f"Missing {section} raw data in comparison_results")
    else:
        logger.error("No comparison_results found in session state")
    
    logger.info("=== END TESTING MODE DATA DEBUG ===")

def validate_financial_data(data: Dict[str, Any]) -> Tuple[bool, str]:
    """
    Validate financial data for consistency.
    
    Args:
        data: Dictionary containing financial data
        
    Returns:
        Tuple of (is_valid, error_message)
    """
    # Check if EGI = GPR - Vacancy Loss + Other Income
    expected_egi = data.get("gpr", 0) - data.get("vacancy_loss", 0) + data.get("other_income", 0)
    actual_egi = data.get("egi", 0)
    
    # Allow for small floating point differences
    if abs(expected_egi - actual_egi) > 1.0:
        return False, f"EGI inconsistency: Expected {expected_egi:.2f}, got {actual_egi:.2f}"
    
    # Check if NOI = EGI - OpEx
    expected_noi = data.get("egi", 0) - data.get("opex", 0)
    actual_noi = data.get("noi", 0)
    
    # Allow for small floating point differences
    if abs(expected_noi - actual_noi) > 1.0:
        return False, f"NOI inconsistency: Expected {expected_noi:.2f}, got {actual_noi:.2f}"
    
    # Check if OpEx components sum up to total OpEx
    # Align component keys with those used in data extraction
    opex_components = [
        "repairs_maintenance", "utilities", 
        "management_fees",  # preferred key
        "property_management",  # legacy key kept for compatibility
        "property_taxes",  # preferred key
        "taxes",           # legacy key kept for compatibility
        "insurance", "administrative", 
        "payroll", "marketing", "other_expenses"
    ]

    # Use dict.fromkeys to preserve order while de-duplicating aliases
    unique_opex_components = list(dict.fromkeys(opex_components))

    opex_sum = sum(data.get(comp, 0) for comp in unique_opex_components)
    total_opex = data.get("opex", 0)
    
    # Allow for small floating point differences
    if abs(opex_sum - total_opex) > 1.0:
        return False, f"OpEx inconsistency: Components sum to {opex_sum:.2f}, but total is {total_opex:.2f}"
    
    # Check if Other Income components sum up to total Other Income
    income_components = [
        "parking", "laundry", "late_fees", "pet_fees", 
        "application_fees", "storage_fees", "amenity_fees", 
        "utility_reimbursements", "cleaning_fees", 
        "cancellation_fees", "miscellaneous"
    ]
    
    income_sum = sum(data.get(component, 0) for component in income_components)
    total_income = data.get("other_income", 0)
    
    # Allow for small floating point differences
    if abs(income_sum - total_income) > 1.0:
        return False, f"Other Income inconsistency: Components sum to {income_sum:.2f}, but total is {total_income:.2f}"
    
    # All checks passed
    return True, ""

def display_document_data(doc_type: str, doc_data: Dict[str, Any]) -> Dict[str, Any]:
    """
    Display and allow editing of data for a specific document type.
    
    Args:
        doc_type: Document type (current_month, prior_month, budget, prior_year)
        doc_data: Dictionary containing document data
        
    Returns:
        Dictionary containing the edited document data
    """
    # Create a deep copy to avoid modifying the original
    edited_doc_data = copy.deepcopy(doc_data)
    
    # Display document metadata
    st.markdown("<h3 style='color: #FFFFFF !important;'>Document Information</h3>", unsafe_allow_html=True)
    with st.expander("Document Metadata", expanded=False):
        col1, col2 = st.columns(2)
        with col1:
            st.text_input("Document Type", value=doc_data.get("document_type", ""), disabled=True, key=f"doc_type_display_{doc_type}")
        with col2:
            st.text_input("Document Date", value=doc_data.get("document_date", ""), disabled=True, key=f"doc_date_display_{doc_type}")
    
    # Auto-calculation option
    auto_calculate = st.checkbox("Auto-calculate dependent values", value=True, key=f"auto_calc_{doc_type}")
    
    # Display main financial metrics
    st.markdown("<h3 style='color: #FFFFFF !important;'>Key Financial Metrics</h3>", unsafe_allow_html=True)
    
    # Create a form for the main metrics
    with st.form(key=f"main_metrics_form_{doc_type}"):
        # GPR
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Gross Potential Rent (GPR)</span>", unsafe_allow_html=True)
        with col2:
            gpr = st.number_input(
                "GPR Value",
                value=float(doc_data.get("gpr", 0.0)),
                format="%.2f",
                step=100.0,
                key=f"gpr_{doc_type}"
            )
            edited_doc_data["gpr"] = gpr
        
         # Vacancy Loss
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Vacancy Loss</span>", unsafe_allow_html=True)
        with col2:
            vacancy_loss = st.number_input(
                "Vacancy Loss Value",
                value=float(doc_data.get("vacancy_loss", 0.0)),
                format="%.2f",
                step=100.0,
                key=f"vacancy_loss_{doc_type}"
            )
            edited_doc_data["vacancy_loss"] = vacancy_loss
        
        # Other Income
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Other Income</span>", unsafe_allow_html=True)
        with col2:
            other_income = st.number_input(
                "Other Income Value",
                value=float(doc_data.get("other_income", 0.0)),
                format="%.2f",
                step=100.0,
                key=f"other_income_{doc_type}"
            )
            edited_doc_data["other_income"] = other_income
        
       # EGI
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Effective Gross Income (EGI)</span>", unsafe_allow_html=True)
        with col2:
            if auto_calculate:
                calculated_egi = edited_doc_data["gpr"] - edited_doc_data["vacancy_loss"] + edited_doc_data["other_income"]
                edited_doc_data["egi"] = calculated_egi
                st.number_input(
                    "EGI Value (Auto-calculated)",
                    value=float(calculated_egi),
                    format="%.2f",
                    step=100.0,
                    key=f"egi_{doc_type}",
                    disabled=True
                )
            else:
                egi = st.number_input(
                    "EGI Value",
                    value=float(doc_data.get("egi", 0.0)),
                    format="%.2f",
                    step=100.0,
                    key=f"egi_{doc_type}"
                )
                edited_doc_data["egi"] = egi
        
        # OpEx
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Operating Expenses (OpEx)</span>", unsafe_allow_html=True)
        with col2:
            opex = st.number_input(
                "OpEx Value",
                value=float(doc_data.get("opex", 0.0)),
                format="%.2f",
                step=100.0,
                key=f"opex_{doc_type}"
            )
            edited_doc_data["opex"] = opex
        
         # NOI
        col1, col2 = st.columns(2)
        with col1:
            st.markdown("<span style='color: #FFFFFF !important; font-weight: bold;'>Net Operating Income (NOI)</span>", unsafe_allow_html=True)
        with col2:
            if auto_calculate:
                calculated_noi = edited_doc_data["egi"] - edited_doc_data["opex"]
                edited_doc_data["noi"] = calculated_noi
                st.number_input(
                    "NOI Value (Auto-calculated)",
                    value=float(calculated_noi),
                    format="%.2f",
                    step=100.0,
                    key=f"noi_{doc_type}",
                    disabled=True
                )
            else:
                noi = st.number_input(
                    "NOI Value",
                    value=float(doc_data.get("noi", 0.0)),
                    format="%.2f",
                    step=100.0,
                    key=f"noi_{doc_type}"
                )
                edited_doc_data["noi"] = noi
        
        # Submit button for the form with loading state
        main_metrics_submitted = st.form_submit_button("Update Main Metrics")
        
        # Handle form submission with loading feedback
        if main_metrics_submitted:
            # Show brief loading feedback
            with st.spinner("Updating main metrics..."):
                time.sleep(0.3)  # Brief feedback for user
            st.success("‚úÖ Main metrics updated successfully!")
    
    # Display Operating Expenses breakdown
    st.markdown("<h3 style='color: #FFFFFF !important;'>Operating Expenses Breakdown</h3>", unsafe_allow_html=True)
    
    # Create a form for OpEx breakdown
    with st.form(key=f"opex_form_{doc_type}"):
        opex_components = [
            ("repairs_maintenance", "Repairs & Maintenance"),
            ("utilities", "Utilities"),
            ("property_management", "Property Management"),
            ("taxes", "Property Taxes"),
            ("insurance", "Insurance"),
            ("administrative", "Administrative"),
            ("payroll", "Payroll"),
            ("marketing", "Marketing"),
            ("other_expenses", "Other Expenses")
        ]
        
        # Create two columns for better layout
        col1, col2 = st.columns(2)
        
        # Distribute OpEx components between columns
        for i, (key, label) in enumerate(opex_components):
            with col1 if i % 2 == 0 else col2:
                value = st.number_input(
                    label,
                    value=float(doc_data.get(key, 0.0)),
                    format="%.2f",
                    step=100.0,
                    key=f"{key}_{doc_type}"
                )
                edited_doc_data[key] = value
        
        # Submit button for the form with loading state
        opex_submitted = st.form_submit_button("Update OpEx Breakdown")
        
        # Handle form submission with loading feedback
        if opex_submitted:
            # Show brief loading feedback
            with st.spinner("Updating OpEx breakdown..."):
                time.sleep(0.3)  # Brief feedback for user
            st.success("‚úÖ OpEx breakdown updated successfully!")
    
    # Display Other Income breakdown
    st.markdown("<h3 style='color: #FFFFFF !important;'>Other Income Breakdown</h3>", unsafe_allow_html=True)
    
    # Create a form for Other Income breakdown
    with st.form(key=f"other_income_form_{doc_type}"):
        income_components = [
            ("parking", "Parking"),
            ("laundry", "Laundry"),
            ("late_fees", "Late Fees"),
            ("pet_fees", "Pet Fees"),
            ("application_fees", "Application Fees"),
            ("storage_fees", "Storage Fees"),
            ("amenity_fees", "Amenity Fees"),
            ("utility_reimbursements", "Utility Reimbursements"),
            ("cleaning_fees", "Cleaning Fees"),
            ("cancellation_fees", "Cancellation Fees"),
            ("miscellaneous", "Miscellaneous")
        ]
        
        # Create two columns for better layout
        col1, col2 = st.columns(2)
        
        # Distribute income components between columns
        for i, (key, label) in enumerate(income_components):
            with col1 if i % 2 == 0 else col2:
                value = st.number_input(
                    label,
                    value=float(doc_data.get(key, 0.0)),
                    format="%.2f",
                    step=100.0,
                    key=f"{key}_{doc_type}"
                )
                edited_doc_data[key] = value
        
        # Submit button for the form with loading state
        income_submitted = st.form_submit_button("Update Other Income Breakdown")
        
        # Handle form submission with loading feedback
        if income_submitted:
            # Show brief loading feedback
            with st.spinner("Updating other income breakdown..."):
                time.sleep(0.3)  # Brief feedback for user
            st.success("‚úÖ Other income breakdown updated successfully!")
    
    # Validate data and show warnings if needed
    is_valid, error_message = validate_financial_data(edited_doc_data)
    if not is_valid:
        st.warning(f"Data inconsistency detected: {error_message}")
        st.info("You can still proceed, but consider fixing the inconsistency for more accurate analysis.")
    
    # Return the edited document data
    return edited_doc_data

def display_data_template(consolidated_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    Display extracted financial data in an editable template format.
    
    Args:
        consolidated_data: Dictionary containing extracted financial data
        
    Returns:
        Dictionary containing the verified/edited financial data
    """
    st.markdown("## Data Extraction Template")
    st.markdown("Review and edit the extracted financial data below. Make any necessary corrections before proceeding with analysis.")
    
    # Create a deep copy of the data to avoid modifying the original
    edited_data = copy.deepcopy(consolidated_data)
    
    # Add auto-confirmation option
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        auto_confirm = st.checkbox(
            "Auto-confirm extracted data and proceed immediately",
            value=False,
            help="Check this to automatically proceed with analysis using the extracted data. Uncheck to review and edit the data first."
        )
    
    # If auto-confirm is enabled, return the data immediately with loading state
    if auto_confirm:
        # Show brief loading for auto-confirm
        loading_container = st.empty()
        with loading_container.container():
            display_inline_loading("Auto-confirming data...", "‚úÖ")
        
        import time
        time.sleep(0.5)  # Brief visual feedback
        
        loading_container.empty()
        st.success("‚úÖ Data auto-confirmed. Proceeding with analysis...")
        return edited_data
    
    # Otherwise, show the manual review interface
    # Create tabs for each document type
    doc_tabs = st.tabs(["Current Month", "Prior Month", "Budget", "Prior Year"])
    
    # Process each document type
    for i, doc_type in enumerate(["current_month", "prior_month", "budget", "prior_year"]):
        with doc_tabs[i]:
            if doc_type in consolidated_data:
                edited_data[doc_type] = display_document_data(doc_type, consolidated_data[doc_type])
            else:
                st.info(f"No {doc_type.replace('_', ' ')} data available.")
    
    # Add confirmation button with loading state
    col1, col2, col3 = st.columns([1, 2, 1])
    with col2:
        confirm_clicked, confirm_button_placeholder = create_loading_button(
            "Confirm Data and Proceed with Analysis",
            key="confirm_data_button",
            type="primary",
            use_container_width=True
        )
        
        if confirm_clicked:
            # Show loading state immediately
            show_button_loading(confirm_button_placeholder, "Confirming Data...")
            
            # Get loading message for data confirmation
            loading_msg, loading_subtitle = get_loading_message_for_action("confirm_data")
            
            # Show loading indicator
            loading_container = st.empty()
            with loading_container.container():
                display_loading_spinner(loading_msg, loading_subtitle)
            
            # Simulate brief processing time for data validation/confirmation
            import time
            time.sleep(1)  # Brief pause to show loading state
            
            # Clear loading states
            loading_container.empty()
            restore_button(confirm_button_placeholder, "Confirm Data and Proceed with Analysis", key="confirm_data_button_restored", type="primary", use_container_width=True)
            
            return edited_data
    
    # Return None if not confirmed
    return None

# Helper function to inject custom CSS
def inject_custom_css():
    """Inject custom CSS to ensure font consistency and enhanced styling across the application"""
    st.markdown("""
    <style>
    /* Reborn Theme CSS for NOI Analyzer */

    /* Import Inter font from Google Fonts */
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    :root {
        /* Color palette based on design specs */
        --reborn-bg-primary: #0A0F1E;
        --reborn-bg-secondary: #10172A;
        --reborn-bg-tertiary: #1E293B;
        --reborn-text-primary: #FFFFFF;  /* Use pure white for maximum readability */
        --reborn-text-secondary: #A0A0A0;
        --reborn-accent-blue: #3B82F6;
        --reborn-accent-green: #10B981;
        --reborn-accent-orange: #F59E0B;
        --reborn-success: #10B981;
        --reborn-warning: #F87171;
        --reborn-border: rgba(255, 255, 255, 0.1);
        
        /* Spacing */
        --reborn-spacing-xs: 8px;
        --reborn-spacing-sm: 16px;
        --reborn-spacing-md: 24px;
        --reborn-spacing-lg: 32px;
        
        /* Border radius */
        --reborn-radius-sm: 6px;
        --reborn-radius-md: 8px;
        --reborn-radius-lg: 12px;
        --reborn-radius-pill: 999px;
        
        /* Shadows */
        --reborn-shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        --reborn-shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        --reborn-shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    /* Base styles */
    body {
        background-color: var(--reborn-bg-primary) !important;
        color: var(--reborn-text-primary) !important;
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif !important;
    }

    /* Streamlit container adjustments */
    .stApp {
        background-color: var(--reborn-bg-primary) !important;
    }

    /* Header styles */
    header {
        background-color: var(--reborn-bg-secondary) !important;
    }

    /* Main content area */
    .main {
        background-color: var(--reborn-bg-primary) !important;
    }

    /* Typography */
    h1, h2, h3, h4, h5, h6 {
        color: var(--reborn-text-primary) !important;
        font-weight: 600 !important;
    }

    /* Streamlit widgets */
    .stTextInput > div > div > input {
        background-color: var(--reborn-bg-tertiary) !important;
        color: var(--reborn-text-primary) !important;
        border: 1px solid var(--reborn-border) !important;
    }

    .stSelectbox > div > div {
        background-color: var(--reborn-bg-tertiary) !important;
        color: var(--reborn-text-primary) !important;
        border: 1px solid var(--reborn-border) !important;
    }

    .stNumberInput > div > div > input {
        background-color: var(--reborn-bg-tertiary) !important;
        color: var(--reborn-text-primary) !important;
        border: 1px solid var(--reborn-border) !important;
    }

    .stButton > button {
        background: linear-gradient(135deg, var(--reborn-accent-blue), #2563eb) !important;
        color: white !important;
        border: none !important;
        border-radius: var(--reborn-radius-md) !important;
        font-weight: 500 !important;
        transition: all 0.2s ease !important;
    }

    .stButton > button:hover {
        background: linear-gradient(135deg, #2563eb, #1d4ed8) !important;
        transform: translateY(-1px) !important;
        box-shadow: var(--reborn-shadow-md) !important;
    }

    .stButton > button:active {
        transform: translateY(0) !important;
    }

    /* File uploader styling */
    .stFileUploader > div {
        background-color: var(--reborn-bg-tertiary) !important;
        border: 2px dashed var(--reborn-border) !important;
        border-radius: var(--reborn-radius-md) !important;
        padding: var(--reborn-spacing-sm) !important;
    }

    /* Dataframe styling */
    .stDataFrame {
        background-color: var(--reborn-bg-secondary) !important;
        border: 1px solid var(--reborn-border) !important;
        border-radius: var(--reborn-radius-md) !important;
    }

    /* Expander styling */
    .streamlit-expanderHeader {
        background-color: var(--reborn-bg-secondary) !important;
        border: 1px solid var(--reborn-border) !important;
        border-radius: var(--reborn-radius-md) !important;
    }

    .streamlit-expanderContent {
        background-color: var(--reborn-bg-secondary) !important;
        border: 1px solid var(--reborn-border) !important;
        border-top: none !important;
        border-radius: 0 0 var(--reborn-radius-md) var(--reborn-radius-md) !important;
    }

    /* Tabs styling */
    .stTabs > div > div {
        background-color: var(--reborn-bg-secondary) !important;
        border: 1px solid var(--reborn-border) !important;
        border-radius: var(--reborn-radius-md) var(--reborn-radius-md) 0 0 !important;
    }

    /* Progress bar styling */
    .stProgress > div > div {
        background: linear-gradient(90deg, var(--reborn-accent-blue), var(--reborn-accent-green)) !important;
    }

    /* Alert styling */
    .stAlert {
        border-radius: var(--reborn-radius-md) !important;
        border: none !important;
    }

    .stAlert[data-baseweb="notification"] {
        background-color: var(--reborn-bg-secondary) !important;
        color: var(--reborn-text-primary) !important;
        border-left: 4px solid var(--reborn-accent-blue) !important;
    }

    /* Custom scrollbar */
    ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
    }

    ::-webkit-scrollbar-track {
        background: var(--reborn-bg-secondary);
    }

    ::-webkit-scrollbar-thumb {
        background: var(--reborn-accent-blue);
        border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: #2563eb;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        :root {
            --reborn-spacing-sm: 12px;
            --reborn-spacing-md: 18px;
            --reborn-spacing-lg: 24px;
        }
    }
    </style>
    """, unsafe_allow_html=True)

def highlight_changes(val):
    """Style helper for pandas Styler to color positive & negative changes."""
    # Ensure we're working with a string for consistent checks
    if not isinstance(val, str):
        val = str(val)

    if val.strip().startswith('-') and any(char.isdigit() for char in val):
        # Bright red for negative values
        return 'color: #EF4444; font-weight: 600;'
    elif val.strip().startswith('+'):
        # Bright green for positive values
        return 'color: #10B981; font-weight: 600;'
    else:
        return ''

def display_opex_breakdown(comp_data: pd.DataFrame, comparison_type: str):
    """
    Display the operating expense breakdown with enhanced styling.
    
    Args:
        comp_data: DataFrame containing the comparison data
        comparison_type: Type of comparison (e.g., 'Budget', 'Prior Month', 'Prior Year')
    """
    # Validate input data
    if comp_data is None or comp_data.empty:
        st.info("No operating expense data available to display.")
        return

    # Filter and prepare data for display
    opex_components = [
        'property_taxes', 'insurance', 'repairs_maintenance', 
        'utilities', 'management_fees', 'payroll', 'marketing', 'other_expenses'
    ]
    
    opex_df_list = []
    for component in opex_components:
        if component in comp_data.columns:
            current_val = comp_data['Current'].get(component, 0.0) or 0.0
            prior_val = comp_data[comparison_type].get(component, 0.0) or 0.0
            
            # Calculate change values
            change_val = (current_val or 0.0) - (prior_val or 0.0)
            percent_change_val = (change_val / (prior_val or 1.0) * 100) if (prior_val or 0.0) != 0 else 0.0
            
            # Skip zero values if show_zero_values is False
            if not st.session_state.get("show_zero_values", True) and (current_val or 0.0) == 0 and (prior_val or 0.0) == 0:
                continue
                
            opex_df_list.append({
                "Expense Category": component.replace('_', ' ').title(),
                "Current": current_val or 0.0,
                comparison_type: prior_val or 0.0,
                "Change ($)": change_val,
                "Change (%)": percent_change_val
            })
    
    if not opex_df_list:
        st.info("No valid operating expense items to display.")
        return

    opex_df = pd.DataFrame(opex_df_list)

    # Format for display
    opex_df_display = opex_df.copy()
    opex_df_display["Current"] = opex_df_display["Current"].apply(lambda x: f"${x:,.2f}")
    opex_df_display[comparison_type] = opex_df_display[comparison_type].apply(lambda x: f"${x:,.2f}")
    opex_df_display["Change ($)"] = opex_df_display["Change ($)"].apply(
        lambda x: f"+${x:,.2f}" if x > 0 else (f"-${abs(x):,.2f}" if x < 0 else f"${x:,.2f}")
    )
    opex_df_display["Change (%)"] = opex_df_display["Change (%)"].apply(
        lambda x: f"+{x:.1f}%" if x > 0 else (f"{x:.1f}%" if x < 0 else f"{x:.1f}%") # Negative sign is inherent
    )

    styled_df = opex_df_display.style.map(
        highlight_changes,
        subset=['Change ($)', 'Change (%)']
    )

    st.markdown("#### Operating Expenses Breakdown")
    st.dataframe(styled_df.format({
        "Current": "{:}",
        comparison_type: "{:}",
        "Change ($)": "{:}",
        "Change (%)": "{:}"
    }), use_container_width=True)

def main():
    """Main Streamlit application function."""
    try:
        # Initialize session state variables if not already set
        if 'show_credit_store' not in st.session_state:
            st.session_state.show_credit_store = False
        if 'user_email' not in st.session_state:
            st.session_state.user_email = ""
        if 'property_name' not in st.session_state:
            st.session_state.property_name = "Sample Property"
        if 'show_zero_values' not in st.session_state:
            st.session_state.show_zero_values = False
        if 'processing_completed' not in st.session_state:
            st.session_state.processing_completed = False
        if 'template_viewed' not in st.session_state:
            st.session_state.template_viewed = False
        if 'show_credit_success' not in st.session_state:
            st.session_state.show_credit_success = False
        if 'terms_accepted' not in st.session_state:
            st.session_state.terms_accepted = False
        if 'show_tos_error' not in st.session_state:
            st.session_state.show_tos_error = False
        if 'user_initiated_processing' not in st.session_state:
            st.session_state.user_initiated_processing = False
        if 'testing_mode' not in st.session_state:
            st.session_state.testing_mode = DEFAULT_TESTING_MODE
        if 'mock_property_name' not in st.session_state:
            st.session_state.mock_property_name = "Test Property"
        if 'mock_scenario' not in st.session_state:
            st.session_state.mock_scenario = "Standard Performance"
        # Initialize the process button creation flag to prevent duplicates
        if 'process_button_created' not in st.session_state:
            st.session_state.process_button_created = False

        st.session_state.template_confirmation_error_count = 0
    except Exception as e:
        logger.error(f"Error in main function initialization: {str(e)}")
        st.error("An error occurred during application initialization. Please refresh the page.")
        return
    
    if 'template_error_count' not in st.session_state:
        st.session_state.template_error_count = 0
    if 'document_processing_exception_count' not in st.session_state:
        st.session_state.document_processing_exception_count = 0
    if 'analysis_error_reset_count' not in st.session_state:
        st.session_state.analysis_error_reset_count = 0
    if 'noi_coach_error_count' not in st.session_state:
        st.session_state.noi_coach_error_count = 0
    if 'testing_mode_toggle_error_count' not in st.session_state:
        st.session_state.testing_mode_toggle_error_count = 0
    if 'testing_mode_scenario_error_count' not in st.session_state:
        st.session_state.testing_mode_scenario_error_count = 0
    if 'testing_mode_clear_error_count' not in st.session_state:
        st.session_state.testing_mode_clear_error_count = 0
    if 'testing_mode_clear_success_error_count' not in st.session_state:
        st.session_state.testing_mode_clear_success_error_count = 0
    if 'tos_error_count' not in st.session_state:
        st.session_state.tos_error_count = 0
    
    # Reset error counters when processing starts successfully
    if st.session_state.get('user_initiated_processing', False) and st.session_state.get('current_month_actuals'):
        st.session_state.document_processing_error_count = 0
        st.session_state.credit_deduction_error_count = 0
        st.session_state.analysis_error_count = 0
        st.session_state.analysis_exception_count = 0
        st.session_state.analysis_exception_count_2 = 0
        st.session_state.results_header_error_count = 0
        st.session_state.template_header_error_count = 0
        st.session_state.document_processing_success_error_count = 0
        st.session_state.template_confirmation_error_count = 0
        st.session_state.template_error_count = 0
        st.session_state.document_processing_exception_count = 0
        st.session_state.analysis_error_reset_count = 0
        st.session_state.noi_coach_error_count = 0
        st.session_state.testing_mode_toggle_error_count = 0
        st.session_state.testing_mode_scenario_error_count = 0
        st.session_state.testing_mode_clear_error_count = 0
        st.session_state.testing_mode_clear_success_error_count = 0
        st.session_state.tos_error_count = 0

    # Main application UI
    try:
        # Display the main application interface
        # Header with logo and title
        st.markdown(
            """
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 2rem;">
                <img src="data:image/png;base64,{}" alt="Reborn AI Logo" style="height: 50px; margin-right: 15px;">
                <h1 style="margin: 0; color: #2563eb; font-family: 'Inter', sans-serif;">NOI Analyzer Enhanced</h1>
            </div>
            """.format(get_reborn_logo_base64()),
            unsafe_allow_html=True
        )
        
        # Display credit balance header
        display_credit_balance_header(st.session_state.user_email)
        
        # Initialize session state for show_zero_values if not present
        if 'show_zero_values' not in st.session_state:
            st.session_state.show_zero_values = True
            
        # Create tabs for different sections
        tab_names = ["Document Upload", "Results", "Financial Narrative", "NOI Coach"]
        if CREDIT_SYSTEM_AVAILABLE:
            tab_names.append("Credit Store")
            
        tabs = st.tabs(tab_names)
        
        with tabs[0]:  # Document Upload tab
            with st.container():
                st.markdown("### üìÅ Document Upload")
                
                # Email input
                email = st.text_input(
                    "üìß Email Address", 
                    value=st.session_state.user_email,
                    help="Enter your email address to receive your analysis and track your credits."
                )
                
                if email != st.session_state.user_email:
                    st.session_state.user_email = email
                    
                # Check if user has sufficient credits
                has_credits, credit_message = check_credits_for_analysis(email) if email else (True, "")
                
                if not has_credits:
                    st.warning(credit_message)
                    display_insufficient_credits()
                else:
                    # Property name input
                    st.markdown("### Property Information")
                    
                    # Property name input - clean and simple
                    property_name = st.text_input(
                        "Property Name",
                        value=st.session_state.property_name,
                        help="Enter the name of the property being analyzed",
                        key="main_property_name_input"
                    )
                    
                    if property_name != st.session_state.property_name:
                        st.session_state.property_name = property_name
                        
                    # Document upload section
                    st.markdown("### üìÑ Financial Documents")
                    
                    # Current month actuals
                    current_month_actuals = st.file_uploader(
                        "Current Month Actuals (Required)",
                        type=["xlsx", "xls", "csv", "pdf"],
                        key="current_month_actuals",
                        help="Upload your current month's profit & loss statement or operating statement."
                    )
                    
                    # Prior month actuals
                    prior_month_actuals = st.file_uploader(
                        "Prior Month Actuals (Optional)",
                        type=["xlsx", "xls", "csv", "pdf"],
                        key="prior_month_actuals",
                        help="Upload last month's financial statement for month-over-month comparison."
                    )
                    
                    # Current month budget
                    current_month_budget = st.file_uploader(
                        "Current Month Budget (Optional)",
                        type=["xlsx", "xls", "csv", "pdf"],
                        key="current_month_budget",
                        help="Upload your budgeted financials for variance analysis."
                    )
                    
                    # Prior year actuals
                    prior_year_actuals = st.file_uploader(
                        "Prior Year Actuals (Optional)",
                        type=["xlsx", "xls", "csv", "pdf"],
                        key="prior_year_actuals",
                        help="Upload the same month from last year for year-over-year comparison."
                    )
                    
                    # Update session state
                    st.session_state.current_month_actuals = current_month_actuals
                    st.session_state.prior_month_actuals = prior_month_actuals
                    st.session_state.current_month_budget = current_month_budget
                    st.session_state.prior_year_actuals = prior_year_actuals
                    
                    # Terms of Service checkbox
                    st.markdown("---")
                    tos_accepted = st.checkbox(
                        "I have read and agree to the [Terms of Service and Usage Agreement](https://noianalyzer.onrender.com/terms)",
                        value=st.session_state.terms_accepted,
                        key="tos_checkbox"
                    )
                    
                    if tos_accepted != st.session_state.terms_accepted:
                        st.session_state.terms_accepted = tos_accepted
                        
                    # Show error if Terms of Service not accepted
                    if st.session_state.show_tos_error:
                        st.error("Please read and accept the Terms of Service to proceed.")
                        st.session_state.show_tos_error = False
                    
                    # Process Documents button
                    process_button_key = "process_documents_button"
                    
                    # Only create the button if it hasn't been created yet
                    if not st.session_state.get('process_button_created', False):
                        if create_loading_button("üöÄ Process Documents", key=process_button_key, disabled=not tos_accepted or not current_month_actuals):
                            # Validate Terms of Service acceptance
                            if not st.session_state.terms_accepted:
                                st.session_state.show_tos_error = True
                                st.rerun()
                            else:
                                # Set flags to indicate user initiated processing
                                st.session_state.user_initiated_processing = True
                                st.session_state.processing_completed = False
                                st.session_state.process_button_created = True
                                
                                # Process the documents
                                with st.spinner("Processing documents and generating insights..."):
                                    try:
                                        # Process all documents
                                        consolidated_data = process_all_documents()
                                        
                                        # Store consolidated data
                                        st.session_state.consolidated_data = consolidated_data
                                        
                                        # Calculate NOI comparisons
                                        comparison_results = calculate_noi_comparisons(consolidated_data)
                                        st.session_state.comparison_results = comparison_results
                                        
                                        # Generate AI insights
                                        if st.session_state.user_email and st.session_state.property_name:
                                            insights = generate_insights_with_gpt(
                                                comparison_results,
                                                st.session_state.property_name
                                            )
                                            st.session_state.insights = insights
                                        
                                        # Mark processing as complete
                                        st.session_state.processing_completed = True
                                        st.session_state.process_button_created = False
                                        
                                        # Switch to Results tab
                                        st.success("Documents processed successfully! Switching to Results tab...")
                                        time.sleep(2)
                                        st.rerun()
                                        
                                    except Exception as e:
                                        logger.error(f"Error processing documents: {str(e)}", exc_info=True)
                                        st.error(f"An error occurred while processing your documents: {str(e)}")
                                        st.session_state.process_button_created = False
                        
                    # Testing mode toggle
                    if DEFAULT_TESTING_MODE:
                        st.markdown("---")
                        st.markdown("### üß™ Testing Mode")
                        
                        testing_mode = st.toggle("Enable Testing Mode", value=st.session_state.testing_mode)
                        
                        if testing_mode != st.session_state.testing_mode:
                            st.session_state.testing_mode = testing_mode
                            st.rerun()
                        
                        if st.session_state.testing_mode:
                            # Mock property name
                            mock_property_name = st.text_input(
                                "Mock Property Name",
                                value=st.session_state.mock_property_name
                            )
                            
                            if mock_property_name != st.session_state.mock_property_name:
                                st.session_state.mock_property_name = mock_property_name
                                
                            # Mock scenario selection
                            mock_scenarios = [
                                "Standard Performance",
                                "High Growth",
                                "Declining Performance",
                                "Seasonal Variations",
                                "Expense Spike",
                                "Revenue Drop"
                            ]
                            
                            mock_scenario = st.selectbox(
                                "Mock Scenario",
                                options=mock_scenarios,
                                index=mock_scenarios.index(st.session_state.mock_scenario) if st.session_state.mock_scenario in mock_scenarios else 0
                            )
                            
                            if mock_scenario != st.session_state.mock_scenario:
                                st.session_state.mock_scenario = mock_scenario
                                
                            # Process Mock Documents button
                            if st.button("üß™ Process Mock Documents"):
                                st.session_state.user_initiated_processing = True
                                st.session_state.processing_completed = False
                                
                                with st.spinner("Processing mock documents and generating insights..."):
                                    try:
                                        # Generate mock consolidated data
                                        mock_scenario = st.session_state.mock_scenario if st.session_state.mock_scenario is not None else "Standard Performance"
                                        mock_consolidated_data = generate_mock_consolidated_data(
                                            st.session_state.mock_property_name,
                                            mock_scenario
                                        )
                                        st.session_state.consolidated_data = mock_consolidated_data
                                        
                                        # Calculate NOI comparisons
                                        mock_comparison_results = calculate_noi_comparisons(mock_consolidated_data)
                                        st.session_state.comparison_results = mock_comparison_results
                                        
                                        # Generate mock insights
                                        mock_scenario = st.session_state.mock_scenario if st.session_state.mock_scenario is not None else "Standard Performance"
                                        mock_insights = generate_mock_insights(mock_scenario)
                                        st.session_state.insights = mock_insights
                                        
                                        # Mark processing as complete
                                        st.session_state.processing_completed = True
                                        
                                        # Switch to Results tab
                                        st.success("Mock documents processed successfully! Switching to Results tab...")
                                        time.sleep(2)
                                        st.rerun()
                                        
                                    except Exception as e:
                                        logger.error(f"Error processing mock documents: {str(e)}", exc_info=True)
                                        st.error(f"An error occurred while processing mock documents: {str(e)}")
                        
                        # Clear Testing Data button
                        if st.button("üßπ Clear Testing Data"):
                            # Reset all session state variables
                            keys_to_reset = [
                                'current_month_actuals', 'prior_month_actuals', 'current_month_budget',
                                'prior_year_actuals', 'consolidated_data', 'processing_completed',
                                'comparison_results', 'insights', 'property_name', 'user_email'
                            ]
                            
                            for key in keys_to_reset:
                                if key in st.session_state:
                                    del st.session_state[key]
                                    
                            st.success("Testing data cleared successfully!")
                            st.rerun()
                
        with tabs[1]:  # Results tab
            if st.session_state.processing_completed and st.session_state.comparison_results:
                st.markdown("### üìä Financial Analysis Results")
                
                # Show/Hide Zero Values toggle
                show_zero_values = st.toggle("Show Zero Values", value=st.session_state.show_zero_values)
                
                if show_zero_values != st.session_state.show_zero_values:
                    st.session_state.show_zero_values = show_zero_values
                    st.rerun()
                
                # Create tabs for different comparisons
                comparison_tabs = st.tabs(["Budget Comparison", "Prior Month Comparison", "Prior Year Comparison"])
                
                # Budget Comparison
                with comparison_tabs[0]:
                    if "budget" in st.session_state.comparison_results:
                        display_comparison_tab(
                            st.session_state.comparison_results["budget"],
                            "budget",
                            "Budget"
                        )
                    else:
                        st.info("Budget comparison data not available.")
                
                # Prior Month Comparison
                with comparison_tabs[1]:
                    if "prior" in st.session_state.comparison_results:
                        display_comparison_tab(
                            st.session_state.comparison_results["prior"],
                            "prior_month",
                            "Prior Month"
                        )
                    else:
                        st.info("Prior month comparison data not available.")
                
                # Prior Year Comparison
                with comparison_tabs[2]:
                    if "prior_year" in st.session_state.comparison_results:
                        display_comparison_tab(
                            st.session_state.comparison_results["prior_year"],
                            "prior_year",
                            "Prior Year"
                        )
                    else:
                        st.info("Prior year comparison data not available.")
                
                # Export to PDF button
                # Export to PDF button
                if st.button("üìÑ Export to PDF Report"):
                    try:
                        st.info("PDF generation is not currently available. This feature will be implemented in a future update.")
                    except Exception as e:
                        logger.error(f"Error with PDF feature: {str(e)}", exc_info=True)
                        st.error(f"An error occurred with the PDF feature: {str(e)}")

                                    mime="application/pdf"
                                )
                            else:
                                st.info("PDF generation is not available at this time. Please try again later.")
                        else:
                            st.info("PDF generation is not available in this environment.")
                            
                    except Exception as e:
                        logger.error(f"Error generating PDF report: {str(e)}", exc_info=True)
                        st.error(f"An error occurred while generating the PDF report: {str(e)}")
            else:
                st.info("Please upload and process documents to see results.")
                
        with tabs[2]:  # Financial Narrative tab
            if st.session_state.processing_completed and st.session_state.comparison_results:
                st.markdown("### üìù Financial Narrative")
                
                try:
                    # Display financial narrative
                    display_financial_narrative(
                        st.session_state.comparison_results,
                        st.session_state.insights,
                        st.session_state.property_name
                    )
                except Exception as e:
                    logger.error(f"Error displaying financial narrative: {str(e)}", exc_info=True)
                    st.error(f"An error occurred while displaying the financial narrative: {str(e)}")
            else:
                st.info("Please upload and process documents to see the financial narrative.")
                
        with tabs[3]:  # NOI Coach tab
            if st.session_state.processing_completed and st.session_state.comparison_results:
                try:
                    # Display NOI Coach
                    if NOI_COACH_AVAILABLE:
                        display_noi_coach_enhanced()
                    else:
                        st.info("NOI Coach is not available in this version.")
                except Exception as e:
                    logger.error(f"Error displaying NOI Coach: {str(e)}", exc_info=True)
                    st.error(f"An error occurred while displaying the NOI Coach: {str(e)}")
            else:
                st.info("Please upload and process documents to use the NOI Coach.")
                
        # Credit Store tab (if available)
        if CREDIT_SYSTEM_AVAILABLE and len(tabs) > 4:
            with tabs[4]:
                try:
                    display_credit_store()
                except Exception as e:
                    logger.error(f"Error displaying credit store: {str(e)}", exc_info=True)
                    st.error(f"An error occurred while displaying the credit store: {str(e)}")
                
        # Display credit success message if needed
        if st.session_state.show_credit_success:
            st.success("Credits added successfully! You can now process more documents.")
            st.session_state.show_credit_success = False
            
    except Exception as e:
        logger.error(f"Error in main application UI: {str(e)}", exc_info=True)
        st.error("An error occurred while loading the application interface. Please refresh the page.")

# Display comparison tab
def display_comparison_tab(tab_data: Dict[str, Any], prior_key_suffix: str, name_suffix: str):
    """
    Display a comparison tab with financial data, charts, and insights.

    Args:
        tab_data: Dictionary containing data for this specific comparison tab.
        prior_key_suffix: Suffix used for prior period keys (e.g., 'prior_month', 'budget').
        name_suffix: Name for the prior period (e.g., 'Prior Month', 'Budget').
    """
    # Ensure name_suffix is safe to use in titles
    name_suffix = safe_text(name_suffix) or "Prior Period" # Ensure fallback
    prior_key_suffix = safe_text(prior_key_suffix) or "prior" # Ensure fallback for key suffix as well

    try:
        logger.info(f"Displaying comparison tab: {name_suffix}")
        add_breadcrumb(f"Displaying comparison tab: {name_suffix}", "ui.display", "info")

        # Ensure tab_data is not None and is a dictionary
        if tab_data is None or not isinstance(tab_data, dict):
            st.error(f"No data available to display for {name_suffix} comparison.")
            logger.warning(f"tab_data is None or not a dict for {name_suffix}")
            return

        # Extract current and prior values safely
        current_values = tab_data.get("current", {})
        prior_values = tab_data.get(prior_key_suffix, {}) # e.g., tab_data.get('prior_month', {})

        if not current_values and not prior_values:
            st.info(f"No financial data found for current or {name_suffix} periods.")
            return
            
        # Main metrics table
        main_metrics_data = []
        metrics_order = [
            ("gpr", "Gross Potential Rent"), ("vacancy_loss", "Vacancy Loss"), 
            ("other_income", "Other Income"), ("egi", "Effective Gross Income"),
            ("opex", "Total Operating Expenses"), ("noi", "Net Operating Income")
        ]

        for key, name in metrics_order:
            current_val = current_values.get(key, 0.0)
            prior_val = prior_values.get(key, 0.0)
            
            # Use .get for change and percent_change with a default of 0.0
            change_val = tab_data.get(f"{key}_change", 0.0) 
            percent_change_val = tab_data.get(f"{key}_percent_change", 0.0)

            main_metrics_data.append({
                "Metric": name,
                "Current": f"${current_val:,.2f}",
                name_suffix: f"${prior_val:,.2f}",
                "Change ($)": f"${change_val:,.2f}",
                "Change (%)": f"{percent_change_val:.1f}%"
            })
        
        main_metrics_df = pd.DataFrame(main_metrics_data)
        
        # --- NEW: Build numeric DataFrame for charts and deeper analysis ---
        chart_data = []
        for key, name in metrics_order:
            current_val_num = float(current_values.get(key, 0.0) or 0.0)
            prior_val_num = float(prior_values.get(key, 0.0) or 0.0)

            # Prefer pre-calculated numeric change if available; otherwise calculate
            change_val_num = tab_data.get(f"{key}_change")
            if change_val_num is None or pd.isna(change_val_num):
                change_val_num = current_val_num - prior_val_num
            change_val_num = float(change_val_num)

            percent_change_num = tab_data.get(f"{key}_percent_change")
            if percent_change_num is None or pd.isna(percent_change_num):
                percent_change_num = (change_val_num / prior_val_num * 100) if prior_val_num else 0.0
            percent_change_num = float(percent_change_num)

            # Align metric naming with helper logic used later in the chart section
            metric_name_chart = "Total OpEx" if name == "Total Operating Expenses" else name

            # Determine business direction (favorable / unfavorable / neutral)
            if metric_name_chart in ["Vacancy Loss", "Total OpEx"]:
                direction = "Favorable" if change_val_num < 0 else ("Unfavorable" if change_val_num > 0 else "Neutral")
            else:
                direction = "Favorable" if change_val_num > 0 else ("Unfavorable" if change_val_num < 0 else "Neutral")

            chart_data.append({
                "Metric": metric_name_chart,
                "Current": current_val_num,
                name_suffix: prior_val_num,
                "Change ($)": change_val_num,
                "Change (%)": percent_change_num,
                "Direction": direction
            })

        # This DataFrame is used later for visualisations
        df = pd.DataFrame(chart_data)
        # --- END NEW CODE ---

        # --- NEW: Main Comparison Bar Chart ---
        st.markdown(f"### Overview")
        
        # Ensure DataFrame has proper column structure to avoid pandas FutureWarnings
        chart_df = df.copy()
        chart_df = chart_df.reset_index(drop=True)
        
        # Create the chart with explicit column handling
        try:
            # Suppress pandas FutureWarnings for plotly express
            import warnings
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=FutureWarning, module="plotly")
                
                main_bar_fig = px.bar(
                    chart_df,
                    x="Metric",
                    y=["Current", name_suffix],
                    barmode="group",
                    labels={"value": "Amount ($)", "variable": "Period", "Metric": ""},
                    color_discrete_map={"Current": "#3B82F6", name_suffix: "#10B981"}
                )
                
            main_bar_fig.update_layout(
                title_text=f"Current vs {name_suffix}",
                title_font_color="#FFFFFF",
                title_font_size=20,
                font_color="#FFFFFF",
                legend_title_text="",
                plot_bgcolor='rgba(0,0,0,0)',
                paper_bgcolor='rgba(0,0,0,0)',
                xaxis=dict(tickangle=-45)
            )
            st.plotly_chart(main_bar_fig, use_container_width=True)
        except Exception as e:
            logger.warning(f"Chart display warning (non-critical): {str(e)}")
            st.info("Chart display temporarily unavailable. Data tables are still available below.")
        # --- END NEW CODE ---

        # Apply styling for changes
        styled_df = main_metrics_df.style.map(
            highlight_changes, 
            subset=['Change ($)', 'Change (%)']
        )
            
        st.dataframe(styled_df, use_container_width=True, hide_index=True)
        
        # Add OpEx Breakdown expander section
        with st.expander("Operating Expense Breakdown", expanded=True):
            opex_components_keys = OPEX_COMPONENTS
            opex_metrics_names = ["Property Taxes", "Insurance", "Repairs & Maintenance", "Utilities", "Management Fees"]

            # Check if any opex components exist in the data (either in current_values or prior_values)
            if any(component in current_values for component in opex_components_keys) or \
               any(f"{component}_{prior_key_suffix}" in tab_data for component in opex_components_keys) or \
               any(component in prior_values for component in opex_components_keys): # Added check for prior_values directly
                
                opex_df_data = []
                category_colors = {
                    "Property Taxes": "#4ecdc4", "Insurance": "#1e88e5",
                    "Repairs & Maintenance": "#8ed1fc", "Utilities": "#ff6b6b",
                    "Management Fees": "#ba68c8"
                }
                
                for key, name in zip(opex_components_keys, opex_metrics_names):
                    current_val_raw = current_values.get(key, tab_data.get(f"{key}_current", 0.0))
                    # Ensure prior_val_raw fetches from all possible keys and defaults to 0.0
                    prior_val_raw = prior_values.get(key, 
                                       tab_data.get(f"{key}_{prior_key_suffix}", 
                                       tab_data.get(f"{key}_compare", 0.0)))

                    current_val = float(current_val_raw) if (current_val_raw is not None and not (isinstance(current_val_raw, float) and pd.isna(current_val_raw))) else 0.0
                    prior_val = float(prior_val_raw) if (prior_val_raw is not None and not (isinstance(prior_val_raw, float) and pd.isna(prior_val_raw))) else 0.0

                    # Prefer pre-calculated change values if available and valid, otherwise calculate
                    change_val_raw = tab_data.get(f"{key}_change", tab_data.get(f"{key}_variance"))
                    if change_val_raw is not None and not (isinstance(change_val_raw, float) and pd.isna(change_val_raw)):
                        change_val = float(change_val_raw)
                    else:
                        change_val = current_val - prior_val

                    percent_change_raw = tab_data.get(f"{key}_percent_change", tab_data.get(f"{key}_percent_variance"))
                    if percent_change_raw is not None and not (isinstance(percent_change_raw, float) and pd.isna(percent_change_raw)):
                        percent_change = float(percent_change_raw)
                    else:
                        percent_change = (change_val / prior_val * 100) if prior_val != 0 else 0.0
                    
                    if not st.session_state.get("show_zero_values", True) and current_val == 0 and prior_val == 0:
                        continue
                        
                    opex_df_data.append({
                        "Expense Category": name,
                        "Current": current_val,
                        name_suffix: prior_val,
                        "Change ($)": change_val,
                        "Change (%)": percent_change,
                        "Color": category_colors.get(name, "#a9a9a9") 
                    })
                
                if opex_df_data:
                    opex_df = pd.DataFrame(opex_df_data)
                    
                    # Create display dataframe without the Color column
                    opex_df_display = opex_df.drop(columns=['Color']).copy()
                    opex_df_display["Current"] = opex_df_display["Current"].apply(lambda x: f"${x:,.2f}")
                    opex_df_display[name_suffix] = opex_df_display[name_suffix].apply(lambda x: f"${x:,.2f}")
                    # Apply + sign for positive changes, - for negative, and no sign for zero.
                    opex_df_display["Change ($)"] = opex_df_display["Change ($)"].apply(
                        lambda x: f"+${x:,.2f}" if x > 0 else (f"-${abs(x):,.2f}" if x < 0 else f"${x:,.2f}")
                    )
                    opex_df_display["Change (%)"] = opex_df_display["Change (%)"].apply(
                        lambda x: f"+{x:.1f}%" if x > 0 else (f"{x:.1f}%" if x < 0 else f"{x:.1f}%") # Negative sign is inherent
                    )
                    
                    # Wrap the styling in a try-except block to handle potential errors
                    try:
                        styled_df = opex_df_display.style.map(
                            highlight_changes, 
                            subset=['Change ($)', 'Change (%)']
                        )
                        
                        st.dataframe(styled_df.format({
                            "Current": "{:}",
                            name_suffix: "{:}",
                            "Change ($)": "{:}",
                            "Change (%)": "{:}"
                        }), use_container_width=True)
                    except Exception as e:
                        logger.warning(f"Error styling OpEx dataframe: {str(e)}")
                        # Fallback to simple dataframe display
                        st.dataframe(opex_df_display, use_container_width=True)

                    # Create columns for charts with enhanced styling
                    col1, col2 = st.columns(2)
                    
                    with col1:
                        # Wrap the chart in a container with our custom styling
                        chart_container_html = '<div class="opex-chart-container"><div class="opex-chart-title">Current Operating Expenses Breakdown</div></div>'
                        st.markdown(chart_container_html, unsafe_allow_html=True)
                        
                        # Filter out zero values for the pie chart
                        try:
                            pie_data = opex_df[opex_df["Current"] > 0]
                            if not pie_data.empty:
                                # Create a custom color map based on our category colors
                                color_map = {row["Expense Category"]: row["Color"] for _, row in pie_data.iterrows()}
                                
                                # Suppress pandas FutureWarnings for plotly express
                                import warnings
                                with warnings.catch_warnings():
                                    warnings.filterwarnings("ignore", category=FutureWarning, module="plotly")
                                    
                                    fig = px.pie(
                                        pie_data, 
                                        values="Current", 
                                        names="Expense Category",
                                        color="Expense Category",
                                        color_discrete_map=color_map,
                                        hole=0.4
                                    )
                                fig.update_layout(
                                    template="plotly_dark",
                                    plot_bgcolor='rgba(13, 17, 23, 0)',
                                    paper_bgcolor='rgba(13, 17, 23, 0)',
                                    font=dict(
                                        family="Inter, sans-serif",
                                        size=14,
                                        color="#e6edf3"
                                    ),
                                    margin=dict(l=20, r=20, t=20, b=20),
                                    legend=dict(
                                        orientation="h",
                                        yanchor="bottom",
                                        y=-0.2,
                                        xanchor="center",
                                        x=0.5,
                                        font=dict(size=12, color="#e6edf3")
                                    ),
                                    showlegend=False  # Hide legend as we have colored indicators in the table
                                )
                                st.plotly_chart(fig, use_container_width=True, config={'displayModeBar': False})
                        except Exception as e:
                            logger.warning(f"Error displaying pie chart: {str(e)}")
                            st.info("Chart display temporarily unavailable.")
                        
                        # Close the chart container
                        st.markdown('</div>', unsafe_allow_html=True)
                    
                    with col2:
                        # Wrap the chart in a container with our custom styling
                        chart_container_html = f'<div class="opex-chart-container"><div class="opex-chart-title">OpEx Components: Current vs {safe_text(name_suffix)}</div></div>'
                        st.markdown(chart_container_html, unsafe_allow_html=True)
                        
                        # Create a horizontal bar chart for comparison
                        try:
                            if not opex_df.empty:
                                # Prepare the data in a format suitable for the horizontal bar chart
                                bar_data = []
                                for _, row in opex_df.iterrows(): # Use the original opex_df with numerical data for charts
                                    bar_data.append({
                                        "Expense Category": row["Expense Category"],
                                        "Amount": row["Current"], # Use numerical "Current"
                                        "Period": "Current",
                                        "Color": row["Color"]
                                    })
                                    bar_data.append({
                                        "Expense Category": row["Expense Category"],
                                        "Amount": row[name_suffix], # Use numerical column for prior/budget
                                        "Period": name_suffix,
                                        "Color": row["Color"] # Can be used if you map colors per category
                                    })
                                
                                # Convert to DataFrame
                                bar_df = pd.DataFrame(bar_data)
                                
                                # Create horizontal bar chart
                                fig2 = px.bar(
                                    bar_df,
                                    x="Amount",
                                    y="Expense Category",
                                    color="Period",
                                    orientation='h',
                                    color_discrete_map={"Current": "#3B82F6", name_suffix: "#10B981"},
                                    barmode='group'
                                )
                                
                                fig2.update_layout(
                                    template="plotly_dark",
                                    plot_bgcolor='rgba(13, 17, 23, 0)',
                                    paper_bgcolor='rgba(13, 17, 23, 0)',
                                    font=dict(
                                        family="Inter, sans-serif",
                                        size=12,
                                        color="#e6edf3"
                                    ),
                                    margin=dict(l=20, r=20, t=20, b=20),
                                    yaxis={'categoryorder':'total ascending'},
                                    xaxis_title="Amount ($)",
                                    yaxis_title="",
                                    legend=dict(
                                        orientation="h",
                                        yanchor="bottom",
                                        y=-0.2,
                                        xanchor="center",
                                        x=0.5,
                                        font=dict(size=12, color="#e6edf3")
                                    )
                                )
                                
                                st.plotly_chart(fig2, use_container_width=True, config={'displayModeBar': False})
                        except Exception as e:
                            logger.warning(f"Error displaying horizontal bar chart: {str(e)}")
                            st.info("Chart display temporarily unavailable.")
                        
                        # Close the chart container
                        st.markdown('</div>', unsafe_allow_html=True)
                else:
                    st.info("No operating expense data available to display.")
            else:
                st.info("No operating expense data found in the comparison results.")
                
        # Add Income Breakdown expander section
        with st.expander("Other Income Breakdown", expanded=False):
            income_components_keys = INCOME_COMPONENTS
            income_metrics_names = [
                "Parking", "Laundry", "Late Fees", "Pet Fees", "Application Fees",
                "Storage Fees", "Amenity Fees", "Utility Reimbursements", 
                "Cleaning Fees", "Cancellation Fees", "Miscellaneous"
            ]

            # Check if any income components exist in the data
            if any(component in current_values for component in income_components_keys) or \
               any(f"{component}_{prior_key_suffix}" in tab_data for component in income_components_keys) or \
               any(component in prior_values for component in income_components_keys):
                
                income_df_data = []
                for key, name in zip(income_components_keys, income_metrics_names):
                    current_val_raw = current_values.get(key, tab_data.get(f"{key}_current", 0.0))
                    # Ensure prior_val_raw fetches from all possible keys and defaults to 0.0
                    prior_val_raw = prior_values.get(key, 
                                       tab_data.get(f"{key}_{prior_key_suffix}", 
                                       tab_data.get(f"{key}_compare", 0.0)))

                    current_val = float(current_val_raw) if (current_val_raw is not None and not (isinstance(current_val_raw, float) and pd.isna(current_val_raw))) else 0.0
                    prior_val = float(prior_val_raw) if (prior_val_raw is not None and not (isinstance(prior_val_raw, float) and pd.isna(prior_val_raw))) else 0.0

                    # Prefer pre-calculated change values if available and valid, otherwise calculate
                    change_val_raw = tab_data.get(f"{key}_change", tab_data.get(f"{key}_variance"))
                    if change_val_raw is not None and not (isinstance(change_val_raw, float) and pd.isna(change_val_raw)):
                        change_val = float(change_val_raw)
                    else:
                        change_val = current_val - prior_val

                    percent_change_raw = tab_data.get(f"{key}_percent_change", tab_data.get(f"{key}_percent_variance"))
                    if percent_change_raw is not None and not (isinstance(percent_change_raw, float) and pd.isna(percent_change_raw)):
                        percent_change = float(percent_change_raw)
                    else:
                        percent_change = (change_val / prior_val * 100) if prior_val != 0 else 0.0
                    
                    if not st.session_state.get("show_zero_values", True) and current_val == 0 and prior_val == 0:
                        continue
                        
                    income_df_data.append({
                        "Income Category": name,
                        "Current": current_val,
                        name_suffix: prior_val,
                        "Change ($)": change_val,
                        "Change (%)": percent_change
                    })
                
                if income_df_data:
                    income_df = pd.DataFrame(income_df_data)
                    
                    # Create display dataframe
                    income_df_display = income_df.copy()
                    income_df_display["Current"] = income_df_display["Current"].apply(lambda x: f"${x:,.2f}")
                    income_df_display[name_suffix] = income_df_display[name_suffix].apply(lambda x: f"${x:,.2f}")
                    # Apply + sign for positive changes, - for negative, and no sign for zero.
                    income_df_display["Change ($)"] = income_df_display["Change ($)"].apply(
                        lambda x: f"+${x:,.2f}" if x > 0 else (f"-${abs(x):,.2f}" if x < 0 else f"${x:,.2f}")
                    )
                    income_df_display["Change (%)"] = income_df_display["Change (%)"].apply(
                        lambda x: f"+{x:.1f}%" if x > 0 else (f"{x:.1f}%" if x < 0 else f"{x:.1f}%") # Negative sign is inherent
                    )
                    
                    # Wrap the styling in a try-except block to handle potential errors
                    try:
                        styled_df = income_df_display.style.map(
                            highlight_changes, 
                            subset=['Change ($)', 'Change (%)']
                        )
                        
                        st.dataframe(styled_df.format({
                            "Current": "{:}",
                            name_suffix: "{:}",
                            "Change ($)": "{:}",
                            "Change (%)": "{:}"
                        }), use_container_width=True)
                    except Exception as e:
                        logger.warning(f"Error styling income dataframe: {str(e)}")
                        # Fallback to simple dataframe display
                        st.dataframe(income_df_display, use_container_width=True)
                else:
                    st.info("No other income data available to display.")
            else:
                st.info("No other income data found in the comparison results.")
                
    except Exception as e:
        logger.error(f"Error in display_comparison_tab: {str(e)}", exc_info=True)
        st.error(f"An error occurred while displaying the {name_suffix} comparison: {str(e)}")

# Run the main function when the script is executed directly
if __name__ == "__main__":
    main()